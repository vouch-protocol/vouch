/**
 * VouchSonicBridge - React Native bridge to Rust Sonic Core
 *
 * This module provides the TypeScript interface to the native Rust
 * library generated by UniFFI. It handles audio buffer processing
 * and watermark detection events.
 *
 * @module VouchSonicBridge
 */

import { NativeModules, NativeEventEmitter, Platform } from 'react-native';

// =============================================================================
// Types (matching Rust UDL definitions)
// =============================================================================

/**
 * Configuration for the Sonic Listener
 */
export interface SonicConfig {
    sampleRate: number;
    frameSizeMs: number;
    detectionThreshold: number;
    spreadingFactor: number;
    enableChirpSync: boolean;
}

/**
 * Result of watermark detection
 */
export interface WatermarkResult {
    detected: boolean;
    confidence: number;
    signerDid: string | null;
    timestamp: number | null;
    payloadHash: string | null;
    covenantJson: string | null;
    audioQuality: number;
    detectionMethod: string;
}

/**
 * Parsed covenant data
 */
export interface VouchCovenant {
    aiTraining: boolean;
    voiceCloning: boolean;
    derivativeWorks: boolean;
    commercialUse: boolean;
    attributionRequired: boolean;
}

/**
 * Listener state
 */
export type ListenerState = 'Idle' | 'Listening' | 'Processing' | 'Error';

/**
 * Event handlers for watermark detection
 */
export interface SonicEventHandlers {
    onWatermarkDetected?: (result: WatermarkResult) => void;
    onAudioLevelChanged?: (levelDb: number) => void;
    onError?: (message: string) => void;
    onStateChanged?: (state: ListenerState) => void;
}

// =============================================================================
// Native Module Interface
// =============================================================================

interface NativeSonicModule {
    createListener(config: SonicConfig): Promise<string>; // Returns listener ID
    startListening(listenerId: string): Promise<void>;
    stopListening(listenerId: string): Promise<void>;
    processBuffer(listenerId: string, pcmData: string): Promise<WatermarkResult>; // Base64 PCM
    processSamples(listenerId: string, samples: number[]): Promise<WatermarkResult>;
    getState(listenerId: string): Promise<ListenerState>;
    isListening(listenerId: string): Promise<boolean>;
    setDetectionThreshold(listenerId: string, threshold: number): Promise<void>;
    getVersion(): Promise<string>;
}

// =============================================================================
// Module Loading
// =============================================================================

/**
 * Check if native module is available
 */
const getNativeModule = (): NativeSonicModule | null => {
    try {
        const { VouchSonicCore } = NativeModules;
        if (VouchSonicCore) {
            return VouchSonicCore as NativeSonicModule;
        }
    } catch {
        // Module not available
    }
    return null;
};

const nativeModule = getNativeModule();
const eventEmitter = nativeModule ? new NativeEventEmitter(NativeModules.VouchSonicCore) : null;

/**
 * Check if native Sonic module is available
 */
export const isSonicAvailable = (): boolean => {
    return nativeModule !== null;
};

/**
 * Get Sonic Core version
 */
export const getSonicVersion = async (): Promise<string> => {
    if (!nativeModule) {
        return 'mock-1.0.0';
    }
    return nativeModule.getVersion();
};

// =============================================================================
// SonicListener Class
// =============================================================================

/**
 * SonicListener - Wrapper for the native Rust SonicListener
 *
 * Provides real-time audio watermark detection using the Vouch Sonic protocol.
 *
 * @example
 * ```typescript
 * const listener = new SonicListener({
 *   sampleRate: 16000,
 *   detectionThreshold: 0.5,
 * });
 *
 * await listener.start({
 *   onWatermarkDetected: (result) => {
 *     console.log('Detected:', result.signerDid);
 *   },
 * });
 *
 * // Later...
 * await listener.stop();
 * ```
 */
export class SonicListener {
    private listenerId: string | null = null;
    private config: SonicConfig;
    private handlers: SonicEventHandlers = {};
    private eventSubscriptions: any[] = [];
    private _isListening = false;

    /**
     * Create a new SonicListener
     */
    constructor(config?: Partial<SonicConfig>) {
        this.config = {
            sampleRate: config?.sampleRate ?? 16000,
            frameSizeMs: config?.frameSizeMs ?? 50,
            detectionThreshold: config?.detectionThreshold ?? 0.5,
            spreadingFactor: config?.spreadingFactor ?? 100,
            enableChirpSync: config?.enableChirpSync ?? true,
        };
    }

    /**
     * Initialize the native listener
     */
    private async ensureInitialized(): Promise<void> {
        if (this.listenerId) return;

        if (!nativeModule) {
            // Create mock listener ID for development
            this.listenerId = `mock-${Date.now()}`;
            console.log('[SonicListener] Using mock implementation');
            return;
        }

        this.listenerId = await nativeModule.createListener(this.config);
        this.setupEventListeners();
    }

    /**
     * Set up native event listeners
     */
    private setupEventListeners(): void {
        if (!eventEmitter || !this.listenerId) return;

        const prefix = `sonic_${this.listenerId}_`;

        this.eventSubscriptions = [
            eventEmitter.addListener(`${prefix}watermark`, (result: WatermarkResult) => {
                this.handlers.onWatermarkDetected?.(result);
            }),
            eventEmitter.addListener(`${prefix}level`, (levelDb: number) => {
                this.handlers.onAudioLevelChanged?.(levelDb);
            }),
            eventEmitter.addListener(`${prefix}error`, (message: string) => {
                this.handlers.onError?.(message);
            }),
            eventEmitter.addListener(`${prefix}state`, (state: ListenerState) => {
                this.handlers.onStateChanged?.(state);
            }),
        ];
    }

    /**
     * Start listening for watermarks
     */
    async start(handlers?: SonicEventHandlers): Promise<void> {
        await this.ensureInitialized();

        if (handlers) {
            this.handlers = handlers;
        }

        if (nativeModule && this.listenerId) {
            await nativeModule.startListening(this.listenerId);
        }

        this._isListening = true;
        this.handlers.onStateChanged?.('Listening');

        console.log('[SonicListener] Started');
    }

    /**
     * Stop listening
     */
    async stop(): Promise<void> {
        if (!this.listenerId) return;

        if (nativeModule) {
            await nativeModule.stopListening(this.listenerId);
        }

        this._isListening = false;
        this.handlers.onStateChanged?.('Idle');

        console.log('[SonicListener] Stopped');
    }

    /**
     * Process PCM audio buffer (for manual audio capture)
     *
     * @param pcmData - 16-bit signed PCM data as Base64 string
     */
    async processBuffer(pcmData: string): Promise<WatermarkResult> {
        await this.ensureInitialized();

        if (!nativeModule || !this.listenerId) {
            // Mock detection for development
            return this.mockDetection();
        }

        return nativeModule.processBuffer(this.listenerId, pcmData);
    }

    /**
     * Process float audio samples
     *
     * @param samples - Audio samples as float array (-1 to 1)
     */
    async processSamples(samples: number[]): Promise<WatermarkResult> {
        await this.ensureInitialized();

        if (!nativeModule || !this.listenerId) {
            // Mock detection for development
            return this.mockDetection();
        }

        return nativeModule.processSamples(this.listenerId, samples);
    }

    /**
     * Update detection threshold
     */
    async setDetectionThreshold(threshold: number): Promise<void> {
        this.config.detectionThreshold = threshold;

        if (nativeModule && this.listenerId) {
            await nativeModule.setDetectionThreshold(this.listenerId, threshold);
        }
    }

    /**
     * Get current configuration
     */
    getConfig(): SonicConfig {
        return { ...this.config };
    }

    /**
     * Check if currently listening
     */
    get isListening(): boolean {
        return this._isListening;
    }

    /**
     * Clean up resources
     */
    dispose(): void {
        this.eventSubscriptions.forEach((sub) => sub.remove());
        this.eventSubscriptions = [];
        this.listenerId = null;
    }

    /**
     * Mock detection for development (when native module unavailable)
     */
    private mockDetection(): WatermarkResult {
        // Simulate random detection for testing
        const detected = Math.random() > 0.7; // 30% detection rate

        if (detected) {
            const result: WatermarkResult = {
                detected: true,
                confidence: 0.85 + Math.random() * 0.15,
                signerDid: 'did:key:z6MkhaXgBZDvotDkL5257faEnNg2dFg857faEnNg',
                timestamp: Date.now(),
                payloadHash: 'a1b2c3d4e5f6',
                covenantJson: JSON.stringify({
                    aiTraining: false,
                    voiceCloning: false,
                }),
                audioQuality: 0.9 + Math.random() * 0.1,
                detectionMethod: 'mock',
            };

            // Emit event
            setTimeout(() => {
                this.handlers.onWatermarkDetected?.(result);
            }, 100);

            return result;
        }

        return {
            detected: false,
            confidence: Math.random() * 0.3,
            signerDid: null,
            timestamp: null,
            payloadHash: null,
            covenantJson: null,
            audioQuality: 0.8 + Math.random() * 0.2,
            detectionMethod: 'mock',
        };
    }
}

// =============================================================================
// Utility Functions
// =============================================================================

/**
 * Parse covenant JSON from watermark result
 */
export const parseCovenant = (result: WatermarkResult): VouchCovenant | null => {
    if (!result.covenantJson) return null;

    try {
        const data = JSON.parse(result.covenantJson);
        return {
            aiTraining: data.aiTraining ?? data.ai_training ?? true,
            voiceCloning: data.voiceCloning ?? data.voice_cloning ?? true,
            derivativeWorks: data.derivativeWorks ?? data.derivative_works ?? true,
            commercialUse: data.commercialUse ?? data.commercial_use ?? true,
            attributionRequired: data.attributionRequired ?? data.attribution_required ?? false,
        };
    } catch {
        return null;
    }
};

/**
 * Format confidence as percentage
 */
export const formatConfidence = (confidence: number): string => {
    return `${(confidence * 100).toFixed(1)}%`;
};

/**
 * Truncate DID for display
 */
export const truncateDid = (did: string, length = 20): string => {
    if (did.length <= length) return did;
    const half = Math.floor(length / 2);
    return `${did.slice(0, half)}...${did.slice(-half)}`;
};

// =============================================================================
// Default Export
// =============================================================================

export default SonicListener;
