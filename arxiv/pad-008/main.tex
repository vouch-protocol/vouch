\input{../common/preamble}

\title{Zero-Friction Identity Bootstrapping via SSH Key Reuse}

\author{Ramprasad Anandam Gaddam\\
\textit{Vouch Protocol Project}\\
\url{https://vouch-protocol.com}\\
\texttt{ram@vouch-protocol.com}}

\date{January 2026}

\begin{document}
\maketitle

\begin{abstract}
This paper presents a method for bootstrapping cryptographic identity from existing SSH keys registered with platforms such as GitHub. Rather than requiring users to generate new keypairs and register new identities, the system leverages SSH keys already associated with developer accounts. This ``piggyback'' approach enables immediate adoption of the Vouch Protocol with zero additional key management burden. We formalize the hybrid verification model, specify the key resolution protocol using platform APIs, and analyze security properties and trust assumptions.

\seriesnote
\end{abstract}

\textbf{Keywords:} SSH keys, identity bootstrapping, zero-friction onboarding, GitHub API, hybrid verification

\section{Introduction}

Adopting new cryptographic identity systems typically requires generating new keypairs, establishing key distribution channels, and building trust in new identifiers. This adoption friction limits uptake of otherwise valuable security systems.

We observe that over 100 million developers already possess cryptographic keys: their SSH keys registered with GitHub, GitLab, and similar platforms. These keys are:
\begin{itemize}
    \item Already generated and stored on developer machines
    \item Already registered with trusted platforms
    \item Already associated with established identities
    \item Already used for high-value operations (code deployment)
\end{itemize}

We present a hybrid verification system that ``piggybacks'' on existing SSH keys, enabling zero-friction adoption of the Vouch Protocol.

\subsection{Contributions}

\begin{itemize}
    \item Hybrid verification model combining SSH keys with Vouch DIDs
    \item Key resolution protocol using platform public key APIs
    \item Security analysis of trust assumptions
    \item Fallback mechanism for non-platform users
\end{itemize}

\section{Background}

\subsection{SSH Key Authentication}

\begin{definition}[SSH Key Pair]
An SSH key pair $(sk, pk)$ where:
\begin{itemize}
    \item $sk$: Private key stored in \texttt{\textasciitilde/.ssh/id\_ed25519}
    \item $pk$: Public key registered with remote services
\end{itemize}
\end{definition}

SSH authentication proves possession of $sk$ through challenge-response signature \citep{rfc4253}.

\subsection{GitHub Key API}

GitHub exposes registered SSH keys via public API:
\begin{lstlisting}
GET https://api.github.com/users/{username}/keys

Response: [
  {"id": 12345, "key": "ssh-ed25519 AAAA..."}
]
\end{lstlisting}

This API requires no authentication and returns all SSH public keys for any user.

\section{Hybrid Verification Model}

\subsection{Verification Priority Chain}

When verifying a Vouch token claiming identity $I$:

\begin{enumerate}
    \item If $I$ is a DID: Resolve DID document, verify using DID key
    \item If $I$ is a GitHub username:
    \begin{enumerate}
        \item Fetch keys from \texttt{api.github.com/users/\{I\}/keys}
        \item Attempt signature verification against each returned key
        \item If any key validates: Verified as GitHub user $I$
    \end{enumerate}
    \item If $I$ is a GitLab username: Similar process with GitLab API
    \item Otherwise: Verification fails
\end{enumerate}

\subsection{Token Format for SSH-Based Identity}

\begin{lstlisting}[language=json]
{
  "iss": "github:alice",
  "iat": 1704844800,
  "exp": 1704845100,
  "vouch": {
    "version": "1.0",
    "payload": {"action": "approve_pr", "pr": 42}
  }
}
\end{lstlisting}

The \texttt{iss} claim uses prefix \texttt{github:} or \texttt{gitlab:} to indicate platform-based identity.

\subsection{Verification Algorithm}

\begin{enumerate}
    \item Parse issuer: $(\mathsf{platform}, \mathsf{username}) = \mathsf{parse}(\mathsf{iss})$
    \item Fetch keys: $K = \mathsf{API.getKeys}(\mathsf{platform}, \mathsf{username})$
    \item For each $pk \in K$:
    \begin{enumerate}
        \item If $\mathsf{Verify}(pk, \mathsf{payload}, \sigma) = 1$: Return $\mathsf{verified}$
    \end{enumerate}
    \item Return $\mathsf{failed}$
\end{enumerate}

\section{Security Analysis}

\subsection{Trust Assumptions}

\begin{property}[Platform Trust]
The system trusts the platform API to return authentic public keys for the claimed username.
\end{property}

This trust assumption is reasonable because:
\begin{itemize}
    \item GitHub/GitLab are widely trusted for code hosting
    \item The same keys are used for production code deployment
    \item Key registration requires account authentication
\end{itemize}

\begin{property}[Key Authenticity]
If GitHub reports key $pk$ for user $U$, then $U$ controls the corresponding $sk$.
\end{property}

\subsection{Threat Analysis}

\textbf{Threat: Platform compromise.} If GitHub is compromised, false keys could be returned. Mitigation: Secondary verification sources, key pinning.

\textbf{Threat: Account takeover.} If a GitHub account is compromised, the attacker can add keys. Mitigation: Key age verification, multi-source verification.

\textbf{Threat: API unavailability.} If GitHub API is down, verification fails. Mitigation: Key caching with TTL.

\subsection{Comparison with Native DIDs}

\begin{center}
\begin{tabular}{lcc}
\toprule
\textbf{Property} & \textbf{SSH Piggyback} & \textbf{Native DID} \\
\midrule
Setup friction & None & Key generation required \\
Trust anchor & Platform & Self-sovereign \\
Platform dependency & Yes & No \\
Key rotation & Platform-managed & Self-managed \\
\bottomrule
\end{tabular}
\end{center}

Users can start with SSH piggyback and migrate to native DIDs later.

\section{Implementation Considerations}

\subsection{Key Caching}

To reduce API calls and handle unavailability:
\begin{equation}
\mathsf{cache}[\mathsf{username}] = (K, t_{\mathsf{fetched}}, \mathsf{TTL})
\end{equation}

Recommended TTL: 1 hour for active verification, 24 hours for fallback.

\subsection{Rate Limiting}

GitHub API rate limits: 60 requests/hour unauthenticated, 5000/hour authenticated. Caching is essential for high-volume verification.

\section{Related Work}

\textbf{Keybase} linked cryptographic keys to social identities but required explicit registration.

\textbf{Web Key Directory} (WKD) provides domain-based key discovery for email; our approach uses platform APIs.

\textbf{GitHub Sigstore Integration} uses OIDC for keyless signing; our approach reuses existing SSH keys.

\section{Implementation}

Reference implementation available at \url{https://github.com/vouch-protocol/vouch}.

Setup command: \texttt{vouch git init} configures repository to use SSH key signing with automatic platform resolution.

\section{Conclusion}

This paper presented SSH-based identity bootstrapping for zero-friction adoption of the Vouch Protocol. By leveraging existing SSH keys and platform APIs, users can begin signing attestations immediately without generating new keys or registering new identities. The hybrid verification model provides a practical on-ramp to cryptographic identity for the developer community.

\priorartbox

\vouchsign{pad008}{Ramprasad Anandam Gaddam}{github:rampyg}

\bibliography{../common/references}

\end{document}
